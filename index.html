✅ やること（全文置き換え・貼る場所）

今回は 2ファイルを全文で更新する。

1) index.html を全文置き換え

GitHubで index.html → ✏️Edit → 全部消す → 下を貼る → Commit

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>集合場所アプリ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Leaflet（白地図・ズーム対応） -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
  </script>

  <link rel="stylesheet" href="style.css">
</head>
<body>

<h2>📍 地図をタップして居住地登録</h2>

<div id="map"></div>

<button onclick="calculateCentroid()">重心を計算</button>

<!-- ▼ 重心の説明（修正版） -->
<div style="margin:10px; font-size:14px; text-align:left; background:#f5f5f5; padding:10px; border-radius:8px;">
  <b>📘 重心の考え方</b><br><br>

  🔴 <b>重み付き重心（各自が別々に来る想定）</b><br>
  人数をそのまま考慮します。<br>
  人数が多い地点ほど、集合場所に強く影響します。<br><br>

  🟢 <b>重みなし重心（乗り合い前提）</b><br>
  同じ地点の人は「1台の車で乗り合って来る」と考えます。<br>
  人数は無視して、地点ごとに同じ重みで計算します。<br><br>

  ※ 人数の偏りが大きいほど、🔴と🟢はズレます。<br>
  ※ 「おすすめスポット」は重心周辺を自動検索して出します（場所によっては少ないことがあります）。
</div>

<div id="result"></div>

<script src="app.js"></script>
</body>
</html>

2) app.js を全文置き換え

GitHubで app.js → ✏️Edit → 全部消す → 下を貼る → Commit

// ================================
// 地図初期化
// ================================
const map = L.map("map").setView([36.5, 138.0], 6);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "© OpenStreetMap contributors"
}).addTo(map);

// ================================
// 登録地点 / マーカー管理
// ================================
let points = [];
let nextPointId = 1;

let centroidMarkers = [];
let lastRecommendationsHtml = "";

// ================================
// Overpass（OSMデータ）検索設定
// ================================
const OVERPASS_ENDPOINTS = [
  "https://overpass-api.de/api/interpreter",
  "https://overpass.kumi.systems/api/interpreter"
];
const POI_RADIUS_M = 30000;     // 30km（車集合の現実ライン）
const POI_LIMIT_EACH = 5;       // カテゴリごとの最大表示数

// ================================
// 地図クリック → ピン追加
// ================================
map.on("click", function (e) {
  const input = prompt("この地点には何人いますか？");
  if (input === null) return;
  if (input === "" || isNaN(input)) {
    alert("数字を入力してください");
    return;
  }

  const count = parseInt(input, 10);
  const id = nextPointId++;

  const marker = L.marker(e.latlng).addTo(map);

  points.push({
    id,
    lat: e.latlng.lat,
    lon: e.latlng.lng,
    count,
    marker
  });

  marker.bindPopup(`
    人数：${count}人<br>
    <button onclick="deleteMarker(${id})">このピンを削除</button>
  `).openPopup();
});

// ================================
// ピン削除（ID方式：削除後も壊れない）
// ================================
function deleteMarker(id) {
  const idx = points.findIndex(p => p.id === id);
  if (idx === -1) return;

  map.removeLayer(points[idx].marker);
  points.splice(idx, 1);

  clearCentroids();
}

// ================================
// 重心マーカー削除
// ================================
function clearCentroids() {
  centroidMarkers.forEach(m => map.removeLayer(m));
  centroidMarkers = [];
  lastRecommendationsHtml = "";
  document.getElementById("result").innerHTML = "";
}

// ================================
// 距離（km）: Haversine
// ================================
function haversineKm(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1 * Math.PI / 180) *
    Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(a));
}

// ================================
// 重みなし球面重心（地点数だけ＝乗り合い前提）
// ================================
function centroidUnweighted(points) {
  let x = 0, y = 0, z = 0;
  const n = points.length;

  points.forEach(p => {
    const lat = p.lat * Math.PI / 180;
    const lon = p.lon * Math.PI / 180;
    x += Math.cos(lat) * Math.cos(lon);
    y += Math.cos(lat) * Math.sin(lon);
    z += Math.sin(lat);
  });

  x /= n; y /= n; z /= n;

  const lon = Math.atan2(y, x);
  const hyp = Math.sqrt(x * x + y * y);
  const lat = Math.atan2(z, hyp);

  return { lat: lat * 180 / Math.PI, lon: lon * 180 / Math.PI };
}

// ================================
// 重み付き球面重心（人数考慮＝各自が別々に来る想定）
// ================================
function centroidWeighted(points) {
  let x = 0, y = 0, z = 0;
  let total = 0;

  points.forEach(p => {
    const lat = p.lat * Math.PI / 180;
    const lon = p.lon * Math.PI / 180;
    const w = p.count;

    x += w * Math.cos(lat) * Math.cos(lon);
    y += w * Math.cos(lat) * Math.sin(lon);
    z += w * Math.sin(lat);

    total += w;
  });

  x /= total; y /= total; z /= total;

  const lon = Math.atan2(y, x);
  const hyp = Math.sqrt(x * x + y * y);
  const lat = Math.atan2(z, hyp);

  return { lat: lat * 180 / Math.PI, lon: lon * 180 / Math.PI };
}

// ================================
// Googleマップ「周辺を探す」リンク（残す）
// ================================
function generateGoogleSearchLinks(lat, lon) {
  const zoom = 11;
  const categories = [
    { name: "♨ 温泉（Googleで探す）", query: "温泉" },
    { name: "🏯 歴史的観光地（Googleで探す）", query: "史跡 OR 城 OR 寺 OR 神社" },
    { name: "🎡 レジャー施設（Googleで探す）", query: "テーマパーク OR レジャー施設" },
    { name: "🎿 スキー場（Googleで探す）", query: "スキー場" },
    { name: "🍽 飲食（Googleで探す）", query: "ご当地グルメ OR 名物 OR 郷土料理 OR 飲食店" },
    { name: "🌃 繁華街（Googleで探す）", query: "繁華街 OR 飲み屋街" },
    { name: "🏨 宿（Googleで探す）", query: "ホテル OR 旅館" },
    { name: "🅿 駐車場（Googleで探す）", query: "駐車場" }
  ];

  let html = "<b>🔎 周辺検索（Googleマップ）</b><ul>";
  for (const cat of categories) {
    const url =
      `https://www.google.com/maps/search/${encodeURIComponent(cat.query)}` +
      `/@${lat},${lon},${zoom}z`;
    html += `<li><a href="${url}" target="_blank">${cat.name}</a></li>`;
  }
  html += "</ul>";
  return html;
}

// ================================
// Overpassクエリ生成（周辺のOSMデータ取得）
// ================================
function buildOverpassQuery(lat, lon, radiusM) {
  // out center で way/relation も中心座標が返る
  // 温泉: amenity=public_bath / bath:type=onsen / natural=hot_spring
  // 歴史: historic=* / tourism=attraction
  // レジャー: tourism=theme_park / leisure=water_park / leisure=park / leisure=sports_centre
  // スキー: landuse=winter_sports / site=piste / piste:type=*
  return `
[out:json][timeout:25];
(
  nwr(around:${radiusM},${lat},${lon})["amenity"="public_bath"];
  nwr(around:${radiusM},${lat},${lon})["bath:type"="onsen"];
  nwr(around:${radiusM},${lat},${lon})["bath:type"="hot_spring"];
  nwr(around:${radiusM},${lat},${lon})["natural"="hot_spring"];

  nwr(around:${radiusM},${lat},${lon})["historic"];
  nwr(around:${radiusM},${lat},${lon})["tourism"="attraction"];

  nwr(around:${radiusM},${lat},${lon})["tourism"="theme_park"];
  nwr(around:${radiusM},${lat},${lon})["leisure"="water_park"];
  nwr(around:${radiusM},${lat},${lon})["leisure"="park"];
  nwr(around:${radiusM},${lat},${lon})["leisure"="sports_centre"];

  nwr(around:${radiusM},${lat},${lon})["landuse"="winter_sports"];
  relation(around:${radiusM},${lat},${lon})["site"="piste"];
  nwr(around:${radiusM},${lat},${lon})["piste:type"];
);
out tags center 200;
`;
}

// ================================
// Overpassへ問い合わせ（エンドポイント切替）
// ================================
async function overpassFetch(query) {
  const body = "data=" + encodeURIComponent(query);

  let lastErr = null;
  for (const ep of OVERPASS_ENDPOINTS) {
    try {
      const res = await fetch(ep, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      lastErr = e;
      // 次のエンドポイントへ
    }
  }
  throw lastErr || new Error("Overpass fetch failed");
}

// ================================
// Overpass結果をカテゴリ分け
// ================================
function categorizeOsm(tags = {}) {
  // 温泉
  if (tags["amenity"] === "public_bath" || tags["bath:type"] === "onsen" || tags["bath:type"] === "hot_spring" || tags["natural"] === "hot_spring") {
    return "♨ 温泉";
  }
  // スキー
  if (tags["landuse"] === "winter_sports" || tags["site"] === "piste" || tags["piste:type"]) {
    return "🎿 スキー場";
  }
  // 歴史
  if (tags["historic"] || tags["tourism"] === "attraction") {
    return "🏯 歴史的観光地";
  }
  // レジャー
  if (tags["tourism"] === "theme_park" || tags["leisure"] === "water_park" || tags["leisure"] === "park" || tags["leisure"] === "sports_centre") {
    return "🎡 レジャー施設";
  }
  return null;
}

function elementLatLon(el) {
  if (typeof el.lat === "number" && typeof el.lon === "number") return { lat: el.lat, lon: el.lon };
  if (el.center && typeof el.center.lat === "number" && typeof el.center.lon === "number") return { lat: el.center.lat, lon: el.center.lon };
  return null;
}

// ================================
// おすすめ生成（距離順・カテゴリ別）
// ================================
async function getRecommendationsHtml(lat, lon) {
  const query = buildOverpassQuery(lat, lon, POI_RADIUS_M);
  const data = await overpassFetch(query);

  const seen = new Set();
  const items = [];

  for (const el of (data.elements || [])) {
    const key = `${el.type}/${el.id}`;
    if (seen.has(key)) continue;
    seen.add(key);

    const ll = elementLatLon(el);
    if (!ll) continue;

    const cat = categorizeOsm(el.tags || {});
    if (!cat) continue;

    const name = (el.tags && el.tags.name) ? el.tags.name : "(名前なし)";
    const dist = haversineKm(lat, lon, ll.lat, ll.lon);

    items.push({
      cat,
      name,
      lat: ll.lat,
      lon: ll.lon,
      distKm: dist
    });
  }

  // カテゴリ別に距離順
  const byCat = new Map();
  for (const it of items) {
    if (!byCat.has(it.cat)) byCat.set(it.cat, []);
    byCat.get(it.cat).push(it);
  }
  for (const [k, arr] of byCat.entries()) {
    arr.sort((a, b) => a.distKm - b.distKm);
    byCat.set(k, arr.slice(0, POI_LIMIT_EACH));
  }

  // HTML化（Googleマップで開ける）
  const order = ["♨ 温泉", "🏯 歴史的観光地", "🎡 レジャー施設", "🎿 スキー場"];

  let html = `<b>⭐ おすすめ（重心から近い順 / 半径約${Math.round(POI_RADIUS_M/1000)}km）</b><br>`;
  html += `<div style="font-size:13px; line-height:1.4;">`;

  let any = false;
  for (const cat of order) {
    const arr = byCat.get(cat) || [];
    html += `<b>${cat}</b><ul>`;
    if (arr.length === 0) {
      html += `<li>近くに見つからない（OSM未登録の可能性あり）</li>`;
    } else {
      any = true;
      for (const it of arr) {
        const g = `https://www.google.com/maps?q=${it.lat},${it.lon}`;
        html += `<li><a href="${g}" target="_blank">${it.name}</a>（約${it.distKm.toFixed(1)}km）</li>`;
      }
    }
    html += `</ul>`;
  }

  if (!any) {
    html += `おすすめが少ない場所です。下の「Googleで探す」を使うのが確実です。`;
  }

  html += `</div>`;
  return html;
}

// ================================
// 重心計算（メイン）
// ================================
async function calculateCentroid() {
  if (points.length === 0) {
    alert("地点が登録されていません");
    return;
  }

  clearCentroids();

  const weighted = centroidWeighted(points);
  const unweighted = centroidUnweighted(points);

  // ---- 重心ピン（赤：重み付き / 緑：重みなし） ----
  const weightedMarker = L.marker([weighted.lat, weighted.lon], {
    icon: L.icon({
      iconUrl: "https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png",
      iconSize: [32, 32],
      iconAnchor: [16, 32]
    })
  }).addTo(map).bindPopup("🔴 重み付き重心（人数考慮）");

  const unweightedMarker = L.marker([unweighted.lat, unweighted.lon], {
    icon: L.icon({
      iconUrl: "https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png",
      iconSize: [32, 32],
      iconAnchor: [16, 32]
    })
  }).addTo(map).bindPopup("🟢 重みなし重心（乗り合い前提）");

  centroidMarkers.push(weightedMarker, unweightedMarker);

  map.setView([weighted.lat, weighted.lon], 7);

  // ---- まずは「検索中…」をポップアップ ----
  weightedMarker.setPopupContent("⭐ おすすめスポットを検索中…").openPopup();

  // ---- おすすめ取得（全国対応：OSMから周辺だけ取る） ----
  try {
    lastRecommendationsHtml = await getRecommendationsHtml(weighted.lat, weighted.lon);
    weightedMarker.setPopupContent(lastRecommendationsHtml).openPopup();
  } catch (e) {
    lastRecommendationsHtml = `<b>⭐ おすすめ</b><br>取得に失敗しました（回線/混雑の可能性）。<br>下の「Googleで探す」を使ってください。`;
    weightedMarker.setPopupContent(lastRecommendationsHtml).openPopup();
  }

  // ---- 結果表示（＋Google検索リンク） ----
  const gW = `https://www.google.com/maps?q=${weighted.lat},${weighted.lon}`;
  const gU = `https://www.google.com/maps?q=${unweighted.lat},${unweighted.lon}`;

  document.getElementById("result").innerHTML = `
    <b>🔴 重み付き重心（人数考慮）</b><br>
    緯度：${weighted.lat.toFixed(5)} / 経度：${weighted.lon.toFixed(5)}<br>
    <a href="${gW}" target="_blank">Googleマップで開く</a><br><br>

    <b>🟢 重みなし重心（乗り合い前提）</b><br>
    緯度：${unweighted.lat.toFixed(5)} / 経度：${unweighted.lon.toFixed(5)}<br>
    <a href="${gU}" target="_blank">Googleマップで開く</a><br><br>

    ${lastRecommendationsHtml}<br>
    ${generateGoogleSearchLinks(weighted.lat, weighted.lon)}
  `;
}

メモ（仕様どおりになってるか）

✅ 「日本全体」＝ OSM全国データから、重心周辺だけ自動取得（重くない） 
wiki.openstreetmap.org
+1

✅ 温泉/歴史/レジャー/スキー場を距離順でおすすめ

✅ Googleマップ検索リンクはそのまま

✅ 重心を出したらおすすめを自動ポップアップ

✅ 重心の説明は 逆を直した（重み付き＝各自、重みなし＝乗り合い）

もし次に「おすすめの半径を切り替え（10km/30km/60km）」とか「カテゴリON/OFF」も欲しくなったら、同じく全文で入れられる。

アプリのアイコン作りたい

アプリ名は「ごじゃ地図」

アイコンは今から自作するけど何センチくらいで作る？

アイコンは「何cm」より **何px（ピクセル）**が基準なんだけど、手描き・自作するなら目安をcmに落とすとこう。

まず結論

原本は 1024×1024 px の正方形で作るのが一番ラク（後から全部作れる）

cmで作りたいなら、編集ソフトの解像度を 300dpi にして
約 8.7 cm × 8.7 cm（= 1024px相当）で作ればOK

1024px ÷ 300dpi = 3.41 inch ≒ 8.66 cm

なんで1024推し？

iOS/Android/PWA全部に変換しやすい

512/192/180/… みたいな必要サイズを劣化少なく書き出せる

書き出し（最低限これだけでOK）

「ごじゃ地図」なら、まずはこの3つ用意すればだいたい困らない：

icon-512.png（512×512）

icon-192.png（192×192）

apple-touch-icon.png（180×180）

余裕があれば追加：

256, 128, 64 もあると安心（Windowsやショートカット周り）

デザインの注意（地味に大事）

スマホの丸角マスクで切れるから、ロゴや文字は 中央の80%以内に収める
（外周ギリギリに文字置くと欠ける）

作るときのソフトが（Procreate / Illustrator / Canva / Photoshop など）どれかだけ教えてくれたら、**そのソフトでの新規キャンバス設定（px・dpi・書き出し手順）**をそのまま貼れる手順で出すよ。

これにしたい．使えるようにあなたが編集して
思考時間: 25s

やった。もらった画像を アプリアイコンとして使える形に整形したよ（白い四隅を消して、円の外側を透明化＋少し余白を追加 → 1024px基準で各サイズ書き出し）。

透明背景（推奨：PWA/ウェブ用）

白背景（端末や環境で透明が微妙なとき用）も用意した

ダウンロード

アイコン一式ZIP

1024px（透明）

512px（透明）

192px（透明）

180px（透明 / iOS）

64px（透明 / favicon向け）

1024px（白背景）

使い方（ごじゃ地図のリポジトリに置く）

ZIPを展開

リポジトリのルートに icons/ フォルダ作る

中に入れる（例）

icons/icon-192.png

icons/icon-512.png

icons/apple-touch-icon-180.png

必要なら、この次に manifest.json / index.html への追記も「全文」で作るよ。

もっとわかりやすく

OK、超わかりやすく書くね。
やることは「ZIPを落として、GitHubにアップする」だけ。

1) まずダウンロード（これだけ）

これを落として👇
アイコン一式ZIP

2) ZIPを開くと入ってるもの（中身）

icon-512.png（一番大事）

icon-192.png（これも必須）

apple-touch-icon-180.png（iPhone用）

ほか（64とか1024とか）

3) GitHubに置く場所（最短コース）

あなたのリポジトリ（juusinn）で：

Add file → Create new file

ファイル名にこれを入力：

icons/.keep


（iconsフォルダを作るためのダミー。中身は何でもOK）

Commit

次に：

Add file → Upload files

ZIPの中からこの3つをアップする：

icon-192.png

icon-512.png

apple-touch-icon-180.png

アップ先はこうなるようにする：

icons/icon-192.png

icons/icon-512.png

icons/apple-touch-icon-180.png

Commit

4) これで何が嬉しい？

次に PWA（ホーム画面に追加） をやるとき、
この icons/ の中身をそのまま使える。

ダウンロードリンク（もう一回）

アイコン一式ZIP

次は「ホーム画面に追加できるアプリ（PWA）」にしたい？
したいなら **manifest.json と index.html を“全文で”**作って、そのまま貼れる形で出す。

OK、状況わかった。
いま **GitHub側の /icons が空（.keepだけ）**で、PCには PNGが揃ってる。
次は そのPNGを /icons にアップするだけ。

✅ いちばん簡単なやり方（今の画面のまま）

あなたの2枚目の画面（juusinn / icons / で .keep が見えてる画面）でやる。

手順

/icons フォルダの画面を開いたままにする
（いまの「.keep」だけの画面）

右上か上部にある 「Add file」 を押す

「Upload files」 を押す

PCのエクスプローラから、次の3つを ドラッグ＆ドロップ

icon-192.png

icon-512.png

apple-touch-icon-180.png

下の Commit changes を押す

これで GitHub側はこうなる👇
icons/icon-192.png
icons/icon-512.png
icons/apple-touch-icon-180.png

✅ もし「Add file」が見つからない場合（代替ルート）

1枚目の画面（リポジトリのトップ）で

icons フォルダをクリックして中に入る

右上の Add file → Upload files

同じようにドラッグ＆ドロップ → Commit

⚠️ いまのPC側の注意（めちゃ大事）

君のエクスプローラの画像だと、拡張子（.png）が非表示になってるっぽい。
でも大丈夫、ファイルの種類が「PNGファイル」ならOK。

アップする時は必ずこの3つね：

icon-192（PNG）

icon-512（PNG）

apple-touch-icon-180（PNG）

※ goja-chizu-icon-1024 と ...whitebg と favicon-64 は「余裕あれば」でOK（後からでいい）

✅ アップできたか確認方法（1秒でわかる）

GitHubの icons フォルダで

icon-192.png

icon-512.png

apple-touch-icon-180.png

の 3つが見えたら勝ち。

次は「ごじゃ地図」をスマホのホーム画面に追加できるようにする（PWA化）だけど、
それやる？やるなら manifest.json と service worker を“全文”で出す。

やる．名前もちゃんとね？

了解。やる。
「ごじゃ地図」って名前で、スマホのホーム画面に追加できる PWA化を一気に完成させる。
約束どおり 全文で出す＆貼る場所も明示する。

0) 先に確認（アイコンの置き場所）

今のリポジトリは icons/ フォルダがある。
この中に最低これが入ってる前提で進める：

icons/icon-192.png

icons/icon-512.png

icons/apple-touch-icon-180.png

（入ってなくても進められるけど、ホーム画面の見た目が弱くなる）

1) index.html（全文置き換え）

GitHubで index.html → ✏️Edit → 全部消す → これを貼る → Commit

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ごじゃ地図</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ごじゃ地図">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon-180.png">

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
  </script>

  <link rel="stylesheet" href="style.css">
</head>
<body>

<h2>📍 ごじゃ地図</h2>
<p style="margin: 8px 10px; font-size: 14px;">
  地図をタップして「居住地ピン」を登録 → 重心を計算して集合場所を決める。
</p>

<div id="map"></div>

<button onclick="calculateCentroid()">重心を計算</button>

<div style="margin:10px; font-size:14px; text-align:left; background:#f5f5f5; padding:10px; border-radius:8px;">
  <b>📘 重心の考え方</b><br><br>

  🔴 <b>重み付き重心（各自が別々に来る想定）</b><br>
  人数をそのまま考慮します。人数が多い地点ほど集合場所に強く影響します。<br><br>

  🟢 <b>重みなし重心（乗り合い前提）</b><br>
  同じ地点の人は「1台の車で乗り合って来る」と考えます。人数は無視して地点ごとに同じ重みで計算します。<br><br>

  ※ 人数の偏りが大きいほど、🔴と🟢はズレます。
</div>

<div id="result"></div>

<script src="app.js"></script>

<!-- Service Worker登録（PWA） -->
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    });
  }
</script>

</body>
</html>

2) manifest.webmanifest（新規作成：全文）

GitHubで Add file → Create new file
ファイル名に manifest.webmanifest
中身はこれを貼る → Commit

{
  "name": "ごじゃ地図",
  "short_name": "ごじゃ地図",
  "start_url": "./",
  "scope": "./",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#ffffff",
  "description": "重心で集合場所を決める地図アプリ（ごじゃ地図）",
  "icons": [
    {
      "src": "icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}

3) sw.js（新規作成：全文）

GitHubで Add file → Create new file
ファイル名に sw.js
中身はこれを貼る → Commit

// ごじゃ地図 PWA Service Worker
// 最低限：オフラインでも起動できるようにする（地図タイルはオンライン必要）

const CACHE_NAME = "goja-chizu-cache-v1";
const ASSETS = [
  "./",
  "./index.html",
  "./style.css",
  "./app.js",
  "./manifest.webmanifest",
  "./icons/icon-192.png",
  "./icons/icon-512.png",
  "./icons/apple-touch-icon-180.png"
];

// インストール時にキャッシュ
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(ASSETS))
  );
  self.skipWaiting();
});

// 古いキャッシュ掃除
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(keys.map((k) => (k === CACHE_NAME ? null : caches.delete(k))))
    )
  );
  self.clients.claim();
});

// 取得：基本はキャッシュ優先、なければネット
self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((cached) => {
      if (cached) return cached;
      return fetch(event.request).catch(() => cached);
    })
  );
});

4) GitHub Pages をON（ここだけ操作）

リポジトリで：

Settings

左の Pages

Source を Deploy from a branch

Branch を main / (root) にして Save

数十秒〜数分で公開URLが出る。

5) スマホで「ホーム画面に追加」

公開URLをSafari/Chromeで開く →

iPhone：共有ボタン → ホーム画面に追加

Android：メニュー → ホーム画面に追加 / アプリをインストール

✅ アイコンが「ごじゃ地図」になってアプリっぽく起動できる。

もし「アイコンが変わらない」時の対処（よくある）

スマホ側のキャッシュが残ってるだけ
→ いったんホーム画面のショートカット削除 → もう一回追加

icons/ のパス違い
→ icons/icon-192.png が実際に存在するか確認

次は（必要なら）
アプリ起動時に「ごじゃ地図」スプラッシュっぽく見せるとか、
オフライン時の注意メッセージも入れられる。
やる？

**アプリ起動時に「ごじゃ地図」スプラッシュっぽく見せる**とか、

なにそれ．説明してから生成

了解。じゃあ「なにそれ？」に答えてからいくね。
（いま出したPWA化そのものじゃなくて、**その次の“見た目の演出”**の話）

「スプラッシュっぽく見せる」って何？

スマホでアプリを起動すると、最初にロゴがドンと出る画面あるでしょ。
あれが スプラッシュ画面。

PWAの場合

本物のスプラッシュ画面は、OS（iPhone/Android）が勝手に出すやつ

iPhoneだと、基本は アイコン＋背景色ベース（細かい自由度は低い）

それとは別に、アプリ側で

起動直後に ロゴ画面を1秒だけ表示→地図に切り替え
みたいな演出もできる
これが「スプラッシュっぽく見せる」＝偽物スプラッシュ（でも体感はかなりアプリ）

なんで入れると嬉しい？

今のごじゃ地図は起動すると、まず地図読み込みで一瞬「間」がある。
そのときに

真っ白で固まった？って不安
を防げる。

スプラッシュを入れると

「起動してる感」が出る

“アプリっぽさ”が爆増

ロゴ（ごじゃ地図）を見せられる

どうやって実装する？

超シンプルで、やることは2つだけ：

index.htmlにロゴ用のdiv（起動画面）を置く

app.jsか小さいscriptで1秒後に消す

つまり “画面の上に一枚かぶせて、あとで消す” だけ。

注意点（正直なところ）

これは 機能ではなく演出

“本物スプラッシュ”はOS側の仕様が強い（特にiPhone）

でも “偽物スプラッシュ”は自由に作れるから確実に効く

じゃあ次どうする？

あなたがやりたいのはどっち？

✅ PWA化（ホーム画面に追加できるようにする）
　→ manifest + sw のやつ（さっきの）

✅ スプラッシュっぽい起動画面の演出を追加
　→ HTML/CSS/JSを少し追加

「まずはPWA化だけ」なら、生成をもう一回 **“説明付き＋全文”**で出し直す。
「PWA化＋スプラッシュ演出まで一気に」なら、それも込みで 全文生成する。

どっちで生成する？

pwaはできてるんだよね？奈良スプラッシュ追加
思考時間: 20s

うん、PWA自体はもうできてる前提でOK。
今回は「起動時にロゴが出て→スッと消える」**スプラッシュ（擬似）**を追加する。

※iPhone/Androidが勝手に出す“本物スプラッシュ”とは別で、
アプリ側で上に1枚かぶせてから消す方式。見た目はほぼアプリ。

✅ やること（1ファイルだけ）
index.html を 全文置き換え

GitHubで index.html → ✏️Edit → 全部消す → 下を貼る → Commit

style.css や app.js は触らない（壊さない）

✅ index.html（全文）
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ごじゃ地図</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- PWA（すでにできてる前提） -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ごじゃ地図">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon-180.png">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="style.css">

  <!-- ▼ スプラッシュ用CSS（style.cssを壊さないため、ここに内蔵） -->
  <style>
    #splash {
      position: fixed;
      inset: 0;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #splash .box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 18px;
    }
    #splash img {
      width: 120px;
      height: 120px;
      border-radius: 24px;
      object-fit: cover;
      box-shadow: 0 10px 24px rgba(0,0,0,0.12);
    }
    #splash .title {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }
    #splash .sub {
      font-size: 13px;
      opacity: 0.65;
    }
    #splash.hide {
      animation: splashFade 300ms ease forwards;
    }
    @keyframes splashFade {
      to { opacity: 0; visibility: hidden; }
    }
    @media (prefers-reduced-motion: reduce) {
      #splash.hide { animation: none; opacity: 0; visibility: hidden; }
    }
  </style>
</head>

<body>
  <!-- ▼ スプラッシュ（起動時にここが一瞬表示される） -->
  <div id="splash" aria-label="ごじゃ地図 起動画面">
    <div class="box">
      <img src="icons/icon-512.png" alt="ごじゃ地図 アイコン">
      <div class="title">ごじゃ地図</div>
      <div class="sub">起動中…</div>
    </div>
  </div>

  <h2>📍 ごじゃ地図</h2>
  <p style="margin: 8px 10px; font-size: 14px;">
    地図をタップして「居住地ピン」を登録 → 重心を計算して集合場所を決める。
  </p>

  <div id="map"></div>

  <button onclick="calculateCentroid()">重心を計算</button>

  <div style="margin:10px; font-size:14px; text-align:left; background:#f5f5f5; padding:10px; border-radius:8px;">
    <b>📘 重心の考え方</b><br><br>

    🔴 <b>重み付き重心（各自が別々に来る想定）</b><br>
    人数をそのまま考慮します。人数が多い地点ほど集合場所に強く影響します。<br><br>

    🟢 <b>重みなし重心（乗り合い前提）</b><br>
    同じ地点の人は「1台の車で乗り合って来る」と考えます。人数は無視して地点ごとに同じ重みで計算します。<br><br>

    ※ 人数の偏りが大きいほど、🔴と🟢はズレます。
  </div>

  <div id="result"></div>

  <script src="app.js"></script>

  <!-- Service Worker登録（PWA） -->
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./sw.js").catch(() => {});
      });
    }
  </script>

  <!-- ▼ スプラッシュ制御：最低0.7秒は見せて、その後スッと消す -->
  <script>
    (function () {
      const splash = document.getElementById("splash");
      if (!splash) return;

      const MIN_SHOW_MS = 700;      // 早すぎるとチカチカするので最低表示
      const MAX_SHOW_MS = 3000;     // 何かが遅くても3秒で強制的に消す
      const started = performance.now();
      let hidden = false;

      function hideSplash() {
        if (hidden) return;
        hidden = true;
        splash.classList.add("hide");
        setTimeout(() => { splash.remove(); }, 400);
      }

      // ページの読み込みが進んだら、最低表示時間を満たしてから消す
      window.addEventListener("load", () => {
        const elapsed = performance.now() - started;
        const wait = Math.max(0, MIN_SHOW_MS - elapsed);
        setTimeout(hideSplash, wait);
      });

      // 保険：いつまでも消えない事故を防ぐ
      setTimeout(hideSplash, MAX_SHOW_MS);
    })();
  </script>
</body>
</html>

✅ 反映できたかチェック

公開ページ（GitHub Pages）を開いて、

起動直後に「ごじゃ地図」ロゴが出る

すぐスッと消えて地図になる

これでOK。

もし「アイコンが出ない」場合

icons/icon-512.png が存在しない or パス違い。
今のリポジトリ構成だと icons/icon-512.png で合ってるはず。

次はスプラッシュの見た目を「もっとアプリっぽく」する？
（背景を淡い地図柄にするとか、ロゴの影・角丸調整とか、読み込み進捗っぽい点滅とか）

アイコン消えない
思考時間: 35s

OK、それはほぼ確実にどっちか：

window.load が発火してない（何かの読み込みが終わらず、スプラッシュ消す処理が走らない）

PWAのService Workerが古い index.html をキャッシュしてて更新が反映されにくい（「消える版」に差し替えたのに、端末が古いのを掴む）

まずは 確実に消える実装に変える。次に PWAキャッシュ対策。

✅ まず1分で直す：index.html のスプラッシュ制御だけ置き換え

あなたの index.html のいちばん下にあるこの部分（スプラッシュ制御の <script> ... </script>）を、丸ごと下のコードに置き換えてCommitして。

置き換えるコード（これにする）
<script>
  (function () {
    const splash = document.getElementById("splash");
    if (!splash) return;

    let hidden = false;
    function hideSplash() {
      if (hidden) return;
      hidden = true;
      splash.classList.add("hide");
      setTimeout(() => splash.remove(), 400);
    }

    // ✅ ここがポイント：loadを待たずに必ず消す（最強）
    // 0.9秒後に必ず消える（体感アプリっぽく、長すぎない）
    setTimeout(hideSplash, 900);

    // もし早く読み込み終わったら、0.7秒は見せてから消す
    const started = performance.now();
    window.addEventListener("load", () => {
      const elapsed = performance.now() - started;
      const wait = Math.max(0, 700 - elapsed);
      setTimeout(hideSplash, wait);
    });

    // 保険：何があっても3秒で消す
    setTimeout(hideSplash, 3000);
  })();
</script>


これで 「loadが来なくても必ず消える」 ようになる。

✅ それでもPWA（ホーム画面）だけ直らない時：sw.js が古いキャッシュを掴んでる

PWAは sw.js が index.htmlをキャッシュしてると、更新が反映されにくい。
対策は簡単で、sw.js の中の CACHE_NAMEを変える（＝強制更新）だけ。

sw.js を全文置き換え（推奨）

GitHubで sw.js → ✏️Edit → 全部消す → これ貼る → Commit

// ごじゃ地図 PWA Service Worker（v2）

const CACHE_NAME = "goja-chizu-cache-v2"; // ★ v1→v2 に変更（これが重要）
const ASSETS = [
  "./",
  "./index.html",
  "./style.css",
  "./app.js",
  "./manifest.webmanifest",
  "./icons/icon-192.png",
  "./icons/icon-512.png",
  "./icons/apple-touch-icon-180.png"
];

self.addEventListener("install", (event) => {
  event.waitUntil(caches.open(CACHE_NAME).then((cache) => cache.addAll(ASSETS)));
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(keys.map((k) => (k === CACHE_NAME ? null : caches.delete(k))))
    )
  );
  self.clients.claim();
});

self.addEventListener("fetch", (event) => {
  const req = event.request;

  // ★ ページ遷移（index.html）はネット優先にして、更新が反映されやすくする
  if (req.mode === "navigate") {
    event.respondWith(
      fetch(req)
        .then((res) => {
          const copy = res.clone();
          caches.open(CACHE_NAME).then((c) => c.put("./index.html", copy));
          return res;
        })
        .catch(() => caches.match("./index.html"))
    );
    return;
  }

  // その他の静的ファイルはキャッシュ優先
  event.respondWith(
    caches.match(req).then((cached) => cached || fetch(req))
  );
});

✅ 最後に、PWA側の更新を確実に反映させる手順（超重要）

ホーム画面の「ごじゃ地図」を一回削除

ブラウザでGitHub PagesのURLを開く

一回リロード

もう一度「ホーム画面に追加」

これで「消えない」が残ってたら、ほぼ消える。

いま一番聞きたい確認（聞くだけで原因が確定する）

「消えない」のはどっち？

A) ブラウザで開いても消えない（PC/スマホChrome等）

B) ホーム画面に追加したPWAだけ消えない

Aなら index.html のスクリプト問題。
Bなら sw.js キャッシュ問題（v2で直る）。

どっち？（A/BだけでOK）

まず1分で直す：`index.html` のスプラッシュ制御だけ置き換え ==================================== あなたの `index.html` のいちばん下にあるこの部分（スプラッシュ制御の `<script> ... </script>`）を、**丸ごと**下のコードに置き換えてCommitして。

全文で

了解。**「全文で」**出すね。
今回は 2ファイルを全文で置き換えすると、ほぼ確実に「消えない」が直る。

index.html：スプラッシュが load待ちでも必ず消えるように修正

sw.js：PWAのキャッシュが原因でも反映されるように v2に更新（index.htmlはネット優先）

✅ やること（コピペだけ）
1) index.html を全文置き換え

GitHubで index.html → ✏️Edit → 全部削除 → 下を貼る → Commit

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ごじゃ地図</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- PWA（既存のまま） -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ごじゃ地図">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon-180.png">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="style.css">

  <!-- スプラッシュ用CSS（style.cssに触れずにここへ） -->
  <style>
    #splash {
      position: fixed;
      inset: 0;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #splash .box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 18px;
    }
    #splash img {
      width: 120px;
      height: 120px;
      border-radius: 24px;
      object-fit: cover;
      box-shadow: 0 10px 24px rgba(0,0,0,0.12);
    }
    #splash .title {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }
    #splash .sub {
      font-size: 13px;
      opacity: 0.65;
    }
    #splash.hide {
      animation: splashFade 300ms ease forwards;
    }
    @keyframes splashFade {
      to { opacity: 0; visibility: hidden; }
    }
    @media (prefers-reduced-motion: reduce) {
      #splash.hide { animation: none; opacity: 0; visibility: hidden; }
    }
  </style>
</head>

<body>
  <!-- スプラッシュ（起動時に一瞬表示） -->
  <div id="splash" aria-label="ごじゃ地図 起動画面">
    <div class="box">
      <img src="icons/icon-512.png" alt="ごじゃ地図 アイコン">
      <div class="title">ごじゃ地図</div>
      <div class="sub">起動中…</div>
    </div>
  </div>

  <h2>📍 ごじゃ地図</h2>
  <p style="margin: 8px 10px; font-size: 14px;">
    地図をタップして「居住地ピン」を登録 → 重心を計算して集合場所を決める。
  </p>

  <div id="map"></div>

  <button onclick="calculateCentroid()">重心を計算</button>

  <div style="margin:10px; font-size:14px; text-align:left; background:#f5f5f5; padding:10px; border-radius:8px;">
    <b>📘 重心の考え方</b><br><br>

    🔴 <b>重み付き重心（各自が別々に来る想定）</b><br>
    人数をそのまま考慮します。人数が多い地点ほど集合場所に強く影響します。<br><br>

    🟢 <b>重みなし重心（乗り合い前提）</b><br>
    同じ地点の人は「1台の車で乗り合って来る」と考えます。人数は無視して地点ごとに同じ重みで計算します。<br><br>

    ※ 人数の偏りが大きいほど、🔴と🟢はズレます。
  </div>

  <div id="result"></div>

  <script src="app.js"></script>

  <!-- Service Worker登録（PWA） -->
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./sw.js").catch(() => {});
      });
    }
  </script>

  <!-- ✅ スプラッシュ制御：load待ちしない。必ず消える版 -->
  <script>
    (function () {
      const splash = document.getElementById("splash");
      if (!splash) return;

      let hidden = false;
      function hideSplash() {
        if (hidden) return;
        hidden = true;
        splash.classList.add("hide");
        setTimeout(() => splash.remove(), 400);
      }

      // 重要：loadが来なくても必ず消す（最強）
      setTimeout(hideSplash, 900);

      // 早く読み込み終わった場合：最低0.7秒は見せてから消す
      const started = performance.now();
      window.addEventListener("load", () => {
        const elapsed = performance.now() - started;
        const wait = Math.max(0, 700 - elapsed);
        setTimeout(hideSplash, wait);
      });

      // 保険：何があっても3秒で消す
      setTimeout(hideSplash, 3000);
    })();
  </script>
</body>
</html>

2) sw.js を全文置き換え（PWAキャッシュ対策）

GitHubで sw.js → ✏️Edit → 全部削除 → 下を貼る → Commit

// ごじゃ地図 PWA Service Worker（v2）
// 目的：PWAで index.html が更新されず「スプラッシュが消えない」などが起きるのを防ぐ

const CACHE_NAME = "goja-chizu-cache-v2"; // ★ v1→v2（強制更新）
const ASSETS = [
  "./",
  "./index.html",
  "./style.css",
  "./app.js",
  "./manifest.webmanifest",
  "./icons/icon-192.png",
  "./icons/icon-512.png",
  "./icons/apple-touch-icon-180.png"
];

self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(ASSETS))
  );
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(
        keys.map((k) => (k === CACHE_NAME ? null : caches.delete(k)))
      )
    )
  );
  self.clients.claim();
});

self.addEventListener("fetch", (event) => {
  const req = event.request;

  // ★ ページ遷移（index.html）はネット優先にして更新を反映しやすくする
  if (req.mode === "navigate") {
    event.respondWith(
      fetch(req)
        .then((res) => {
          const copy = res.clone();
          caches.open(CACHE_NAME).then((c) => c.put("./index.html", copy));
          return res;
        })
        .catch(() => caches.match("./index.html"))
    );
    return;
  }

  // 静的ファイルはキャッシュ優先
  event.respondWith(
    caches.match(req).then((cached) => cached || fetch(req))
  );
});

✅ 最後の仕上げ（PWAの反映を確実にする）

Commitしたらスマホで：

ホーム画面の「ごじゃ地図」を削除

ブラウザでGitHub PagesのURLを開く

1回リロード

もう一回「ホーム画面に追加」

これでスプラッシュは必ず消える。

もしそれでも消えない場合は、原因はほぼ
icons/icon-512.png が読めずに画像が固まってるとかじゃなく CSS/JS自体が更新されてない系なので、上の sw.js v2 が刺さるはず。
